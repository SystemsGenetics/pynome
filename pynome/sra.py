"""
===========
SRA Helpers
===========

This module will write an sra.txt to each genome. sra.txt will contain a list
of accession numbers that are retrieved from a search using the corresponding
taxonomy id.


Filter criteria:

1)  read length >= 100bp
2)  # of spots (reads): 10 Million
3)  PAIRED reads only
4)  Species with genome and GFF3 file.
5)  Illumina sequencers.
6)  Assay Type: RNA-Seq

https://www.ncbi.nlm.nih.gov/books/NBK25499/

**Sample Search String**

``(((((txid39946[Organism:noexp]) AND "biomol rna"[Properties]) AND
"illumina"[Platform]) AND "type rnaseq"[Filter])) AND 100:1000[ReadLength]``


"""

import urllib
import xmltodict


QUERY = ("https://eutils.ncbi.nlm.nih.gov"
         "/entrez/eutils/esearch.fcgi?db=sra&term=")

FETCH = ('https://eutils.ncbi.nlm.nih.gov'
         '/entrez/eutils/efetch.fcgi?db=sra&id=')


def build_sra_search(tax_id):
    """
    Builds the SRA search string based on an input taxonomy id number.
    """

    # Define discreet portions of the search string.
    tax_id_str = "txid{}[Organism:noexp]".format(tax_id)
    properties_str = 'biomol+rna[Properties]'
    platform_str = 'platform+illumina[Properties]'
    read_length_str = '100:1000[ReadLength]'
    layout_paired_str = '"paired"[Layout]'

    # Build the output string.
    out_str = '+AND+'.join((
        tax_id_str,
        properties_str,
        platform_str,
        read_length_str,
        layout_paired_str))

    return out_str


def run_sra_search(sra_query_str):
    """
    Runs the actual query.

    :param sra_query_str:
        A string that defines the desired search term.

    :returns:
        Eutils server response formatted as a dictionary.

    """

    # Build the query string, &retmax=100000 is the maximum number
    # of values that eutils will be return.
    query = QUERY + sra_query_str + "&retmax=100000"

    # Query the remote source and read the response.
    with urllib.request.urlopen(query) as response:
        response_xml = response.read()

    # Parse the returned XML and return the data as a dictionary.
    response = xmltodict.parse(response_xml)

    return response


def fetch_sra_info(sra_ID):
    """
    Retrieves the information associated with a response ID.
    
    ..todo::
        Confirm that the XML returned by this function is the
        `*.sra.json` file as outlined in the project notes.

    :param sra_ID:
        A query ID returned by run_sra_search().

    :returns:
        An collections.OrderedDict object from the SRA archive.
    """

    # Build the search string.
    fetch_str = FETCH + sra_ID

    # Query the remote source and save the response.
    with urllib.request.urlopen(fetch_str) as response:
        response_xml = response.read()

    # Parse the XML returned and return an dictionary.
    response = xmltodict.parse(response_xml)

    return response


def parse_sra_acession_response(response):
    """
    Parses an OrderedDict response object, as retrieved 
    from `fetch_sra_info`.
    
    The desired fetch IDs are in the nested list:
    
    ``response['eSearchResult']['IdList']['Id']``
    
    :returns:
        A liist of fetch IDs.
    
    """
    
    # Return correct list from the response if it exists.
    # Otherwise this function will return `None`.
    if response['eSearchResult']['IdList']['Id'] is not None:
        return response['eSearchResult']['IdList']['Id']
    

def write_sra_json(sra_path, sra_dict):
    """
    Creates an `"[sra_id].sra.json"` file and saves it to the
    supplied directory.
    
    :param sra_path:
        The complete path to save write the file to.
        
    :param sra_xml:
        The response XML to save.
    """
    
    file_name = None
    
    return

def get_sra_path(sra_id):
    """
    Builds an sra file path based on the `sra_id` paramater.
    
    :param sra_id:
        The SRA ID of an entry.
        
    :returns:
        A file path generated by os.path().
    """